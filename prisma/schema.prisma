generator client {
  provider     = "prisma-client"
  output       = "../src/generated/prisma"
  runtime      = "bun"
  moduleFormat = "esm"
}

datasource db {
  provider = "postgresql"
}

// -----------------------------
// Users & Auth
// -----------------------------
model User {
  id            String   @id @default(cuid())
  name          String
  email         String   @unique
  emailVerified Boolean  @default(false)
  image         String?
  isActive      Boolean  @default(true)
  role          UserRole @default(STAFF)
  banned        Boolean? @default(false)
  banReason     String?
  banExpires    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions Session[]
  accounts Account[]

  createdProducts       Product[]              @relation("ProductCreator")
  createdPurchaseOrders PurchaseOrder[]        @relation("POCreator")
  createdSalesOrders    SalesOrder[]           @relation("SOCreator")
  stockMovements        StockMovement[]        @relation("MovementCreator")
  inventoryAdjustments  InventoryAdjustment[]
  activityLogs          ActivityLog[]
  inventoryTransactions InventoryTransaction[]

  @@map("user")
}

enum UserRole {
  SUPER_ADMIN
  ADMIN
  MANAGER
  STAFF
  VIEWER
}

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  impersonatedBy String?
  userId    String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id @default(cuid())
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

// -----------------------------
// ORGANIZATION & LOCATION
// -----------------------------
model Warehouse {
  id         String    @id @default(cuid())
  name       String
  code       String    @unique
  address    String?
  district   String?
  country    String    @default("Uganda")
  postalCode String?
  isActive   Boolean   @default(true)
  deletedAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  locations            Location[]
  stockItems           StockItem[]
  stockMovements       StockMovement[]       @relation("FromWarehouse")
  stockMovementsTo     StockMovement[]       @relation("ToWarehouse")
  goodsReceiptItems    GoodsReceiptItem[]
  inventoryAdjustments InventoryAdjustment[]

  @@map("warehouses")
}

model Location {
  id          String       @id @default(cuid())
  warehouseId String
  name        String // e.g., "Aisle A, Shelf 3, Bin 2"
  code        String       @unique
  type        LocationType @default(STANDARD)
  isActive    Boolean      @default(true)
  deletedAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  warehouse         Warehouse          @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  stockItems        StockItem[]
  goodsReceiptItems GoodsReceiptItem[]

  @@index([warehouseId])
  @@map("locations")
}

enum LocationType {
  STANDARD
  QUARANTINE
  DAMAGED
  RETURNS
  STAGING
}

// -----------------------------
// PRODUCT CATALOG
// -----------------------------
model Category {
  id          String    @id @default(cuid())
  name        String
  description String?
  parentId    String?
  isActive    Boolean   @default(true)
  deletedAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations - Self-referential for nested categories
  parent   Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children Category[] @relation("CategoryHierarchy")
  products Product[]

  @@map("categories")
}

model Product {
  id          String  @id @default(cuid())
  sku         String  @unique
  barcode     String? @unique
  name        String
  description String?
  categoryId  String?

  // Tracking settings
  trackBySerialNumber Boolean @default(false)
  trackByBatch        Boolean @default(false)
  trackByExpiry       Boolean @default(false)

  // Physical attributes
  unit       String   @default("pcs") // pcs, kg, liter, etc.
  weight     Decimal? @db.Decimal(10, 3)
  weightUnit String? // kg, g, lb
  dimensions String? // LxWxH format

  // Costing (Int used for currency, no decimals)
  costPrice    Int? // stored as integer shillings
  sellingPrice Int?
  taxRate      Int? // percentage or basis agreed

  // Reordering
  reorderPoint    Int? @default(0)
  reorderQuantity Int?
  minimumStock    Int? @default(0)
  maximumStock    Int?

  // Status
  isActive  Boolean   @default(true)
  isKit     Boolean   @default(false) // Can be assembled from components
  deletedAt DateTime?

  // Metadata
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  category           Category?           @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  createdBy          User                @relation("ProductCreator", fields: [createdById], references: [id], onDelete: Restrict)
  suppliers          ProductSupplier[]
  stockItems         StockItem[]
  purchaseOrderItems PurchaseOrderItem[]
  salesOrderItems    SalesOrderItem[]

  // For kits/assemblies
  kitComponents        KitComponent[]        @relation("KitProduct")
  usedInKits           KitComponent[]        @relation("ComponentProduct")
  goodsReceiptItems    GoodsReceiptItem[]
  inventoryAdjustments InventoryAdjustment[]

  @@map("products")
}

model KitComponent {
  id          String  @id @default(cuid())
  kitId       String
  componentId String
  quantity    Decimal @db.Decimal(10, 3)

  createdAt DateTime @default(now())

  kit       Product @relation("KitProduct", fields: [kitId], references: [id], onDelete: Cascade)
  component Product @relation("ComponentProduct", fields: [componentId], references: [id], onDelete: Restrict)

  @@unique([kitId, componentId])
  @@map("kit_components")
}

// -----------------------------
// SUPPLIER MANAGEMENT
// -----------------------------
model Supplier {
  id            String  @id @default(cuid())
  name          String
  code          String  @unique
  contactPerson String?
  email         String?
  phone         String?
  address       String?
  city          String?
  country       String?

  paymentTerms String? // e.g., "Net 30", "COD"
  taxId        String?

  isActive  Boolean   @default(true)
  deletedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  products       ProductSupplier[]
  purchaseOrders PurchaseOrder[]

  @@map("suppliers")
}

model ProductSupplier {
  id              String   @id @default(cuid())
  productId       String
  supplierId      String
  supplierSku     String? // Supplier's product code
  leadTimeDays    Int?
  minimumOrderQty Decimal? @db.Decimal(10, 3)
  costPrice       Int? // changed to Int to be consistent with currency representation
  isPreferred     Boolean  @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  product  Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  supplier Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  @@unique([productId, supplierId])
  @@index([supplierId])
  @@map("product_suppliers")
}

// -----------------------------
// STOCK (single source of truth via movements + StockItem as current snapshot)
// -----------------------------
model StockItem {
  id          String  @id @default(cuid())
  productId   String
  warehouseId String
  locationId  String?

  // Tracking identifiers
  batchNumber  String?
  serialNumber String? // keep unique globally if used (see index)
  expiryDate   DateTime?

  // Quantities (current on-hand snapshot)
  quantity         Decimal @db.Decimal(10, 3) // updated only by transactional flows that create StockMovement(s)
  reservedQuantity Decimal @default(0) @db.Decimal(10, 3) // reserved for confirmed sales
  // available = quantity - reserved (compute when reading)

  // Costing (Int used for unit cost)
  unitCost Int?

  // Status
  status StockStatus @default(AVAILABLE)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  product   Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  warehouse Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  location  Location? @relation(fields: [locationId], references: [id], onDelete: SetNull)

  // Prevent duplicate stock bucket rows for same identifiers (serials/batches included).
  @@unique([productId, warehouseId, locationId, batchNumber, serialNumber])
  @@index([productId, warehouseId])
  @@index([batchNumber])
  @@index([serialNumber])
  @@map("stock_items")
}

enum StockStatus {
  AVAILABLE
  QUARANTINE
  DAMAGED
  RESERVED
  IN_TRANSIT
}

// -----------------------------
// PURCHASE ORDERS
// -----------------------------
model PurchaseOrder {
  id          String @id @default(cuid())
  orderNumber String @unique
  supplierId  String

  orderDate    DateTime  @default(now())
  expectedDate DateTime?
  receivedDate DateTime?

  status POStatus @default(DRAFT)

  // Financials - Ints (shillings)
  subtotal     Int
  taxAmount    Int @default(0)
  shippingCost Int @default(0)
  totalAmount  Int

  notes String?

  createdById String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  // Relations
  supplier  Supplier            @relation(fields: [supplierId], references: [id], onDelete: Restrict)
  createdBy User                @relation("POCreator", fields: [createdById], references: [id], onDelete: Restrict)
  items     PurchaseOrderItem[]
  receipts  GoodsReceipt[]

  @@index([supplierId])
  @@map("purchase_orders")
}

enum POStatus {
  DRAFT
  SUBMITTED
  APPROVED
  PARTIALLY_RECEIVED
  RECEIVED
  CANCELLED
}

model PurchaseOrderItem {
  id              String @id @default(cuid())
  purchaseOrderId String
  productId       String

  quantity         Decimal @db.Decimal(10, 3)
  receivedQuantity Decimal @default(0) @db.Decimal(10, 3)
  unitPrice        Int
  taxRate          Int
  totalPrice       Int // store for audit, but recalc in application logic to ensure integrity

  notes String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  purchaseOrder PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  product       Product       @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@index([productId])
  @@map("purchase_order_items")
}

model GoodsReceipt {
  id              String  @id @default(cuid())
  receiptNumber   String  @unique
  purchaseOrderId String?

  receivedDate DateTime @default(now())
  receivedBy   String

  notes String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  purchaseOrder PurchaseOrder?     @relation(fields: [purchaseOrderId], references: [id], onDelete: SetNull)
  items         GoodsReceiptItem[]

  @@map("goods_receipts")
}

model GoodsReceiptItem {
  id        String @id @default(cuid())
  receiptId String
  productId String

  quantity    Decimal   @db.Decimal(10, 3)
  batchNumber String?
  expiryDate  DateTime?

  warehouseId String
  locationId  String?

  createdAt DateTime @default(now())

  receipt   GoodsReceipt @relation(fields: [receiptId], references: [id], onDelete: Cascade)
  product   Product      @relation(fields: [productId], references: [id], onDelete: Restrict)
  warehouse Warehouse    @relation(fields: [warehouseId], references: [id], onDelete: Restrict)
  location  Location?    @relation(fields: [locationId], references: [id], onDelete: SetNull)

  @@index([productId])
  @@map("goods_receipt_items")
}

// -----------------------------
// SALES ORDERS
// -----------------------------
model Customer {
  id      String  @id @default(cuid())
  name    String
  code    String  @unique
  email   String?
  phone   String?
  address String?
  city    String?
  country String?

  paymentTerms String?
  creditLimit  Int? // in shillings
  taxId        String?

  isActive  Boolean   @default(true)
  deletedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salesOrders SalesOrder[]

  @@map("customers")
}

model SalesOrder {
  id          String @id @default(cuid())
  orderNumber String @unique
  customerId  String

  orderDate    DateTime  @default(now())
  requiredDate DateTime?
  shippedDate  DateTime?

  status SOStatus @default(DRAFT)

  subtotal     Int
  taxAmount    Int
  shippingCost Int
  totalAmount  Int

  shippingAddress String?
  notes           String?

  createdById String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  customer  Customer         @relation(fields: [customerId], references: [id], onDelete: Restrict)
  createdBy User             @relation("SOCreator", fields: [createdById], references: [id], onDelete: Restrict)
  items     SalesOrderItem[]
  shipments Shipment[]

  @@index([customerId])
  @@map("sales_orders")
}

enum SOStatus {
  DRAFT
  CONFIRMED
  PARTIALLY_FULFILLED
  FULFILLED
  SHIPPED
  DELIVERED
  CANCELLED
}

model SalesOrderItem {
  id           String @id @default(cuid())
  salesOrderId String
  productId    String

  quantity        Decimal @db.Decimal(10, 3)
  shippedQuantity Decimal @default(0) @db.Decimal(10, 3)
  unitPrice       Int
  taxRate         Int
  totalPrice      Int // store for audit, but recalc in application logic

  notes String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salesOrder SalesOrder @relation(fields: [salesOrderId], references: [id], onDelete: Cascade)
  product    Product    @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@index([productId])
  @@map("sales_order_items")
}

model Shipment {
  id             String @id @default(cuid())
  shipmentNumber String @unique
  salesOrderId   String

  shippedDate    DateTime  @default(now())
  deliveredDate  DateTime?
  trackingNumber String?
  carrier        String?

  status ShipmentStatus @default(PENDING)

  notes String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salesOrder SalesOrder     @relation(fields: [salesOrderId], references: [id], onDelete: Cascade)
  items      ShipmentItem[]

  @@map("shipments")
}

enum ShipmentStatus {
  PENDING
  PICKED
  PACKED
  SHIPPED
  IN_TRANSIT
  DELIVERED
  RETURNED
}

model ShipmentItem {
  id         String @id @default(cuid())
  shipmentId String
  productId  String

  quantity     Decimal @db.Decimal(10, 3)
  batchNumber  String?
  serialNumber String?

  createdAt DateTime @default(now())

  shipment Shipment @relation(fields: [shipmentId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@map("shipment_items")
}

// -----------------------------
// INVENTORY TRANSACTIONS & MOVEMENTS (single source of truth)
// -----------------------------
model InventoryTransaction {
  id                String       @id @default(cuid())
  transactionNumber String       @unique
  type              MovementType
  referenceType     String? // e.g., "PurchaseOrder", "SalesOrder", "GoodsReceipt"
  referenceId       String? // id of the referenced entity
  notes             String?
  createdById       String
  createdAt         DateTime     @default(now())

  // Relations
  movements StockMovement[] @relation("TransactionMovements")
  createdBy User            @relation(fields: [createdById], references: [id], onDelete: Restrict)

  @@index([referenceType, referenceId])
  @@map("inventory_transactions")
}

enum MovementType {
  PURCHASE_RECEIPT
  SALES_SHIPMENT
  TRANSFER
  ADJUSTMENT
  RETURN
  ASSEMBLY
  DISASSEMBLY
}

model StockMovement {
  id             String       @id @default(cuid())
  movementNumber String       @unique
  type           MovementType

  productId       String
  fromWarehouseId String?
  toWarehouseId   String?

  quantity     Decimal @db.Decimal(10, 3)
  batchNumber  String?
  serialNumber String?

  reason                 String?
  referenceNumber        String? // e.g., PO number, SO number
  inventoryTransactionId String? // groups movements into a single business event

  createdById String
  createdAt   DateTime @default(now())

  // Relations
  fromWarehouse Warehouse? @relation("FromWarehouse", fields: [fromWarehouseId], references: [id], onDelete: SetNull)
  toWarehouse   Warehouse? @relation("ToWarehouse", fields: [toWarehouseId], references: [id], onDelete: SetNull)
  createdBy     User       @relation("MovementCreator", fields: [createdById], references: [id], onDelete: Restrict)

  inventoryTransaction InventoryTransaction? @relation("TransactionMovements", fields: [inventoryTransactionId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@index([fromWarehouseId])
  @@index([toWarehouseId])
  @@map("stock_movements")
}

// -----------------------------
// ADJUSTMENTS
// -----------------------------
model InventoryAdjustment {
  id               String @id @default(cuid())
  adjustmentNumber String @unique

  productId   String
  warehouseId String
  batchNumber String?

  previousQuantity Decimal @db.Decimal(10, 3)
  adjustedQuantity Decimal @db.Decimal(10, 3)
  difference       Decimal @db.Decimal(10, 3)

  reason AdjustmentReason
  notes  String?

  createdById String
  createdAt   DateTime @default(now())

  createdBy User      @relation(fields: [createdById], references: [id], onDelete: Restrict)
  product   Product   @relation(fields: [productId], references: [id], onDelete: Restrict)
  warehouse Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Restrict)

  @@map("inventory_adjustments")
}

enum AdjustmentReason {
  PHYSICAL_COUNT
  DAMAGE
  LOSS
  FOUND
  EXPIRY
  QUALITY_ISSUE
  OTHER
}

// -----------------------------
// REPORTING & ANALYTICS
// -----------------------------
model StockSnapshot {
  id          String @id @default(cuid())
  productId   String
  warehouseId String

  date     DateTime @default(now())
  quantity Decimal  @db.Decimal(10, 3)
  value    Int // monetary value in Int (shillings)

  createdAt DateTime @default(now())

  @@index([date])
  @@index([productId, warehouseId, date])
  @@map("stock_snapshots")
}

// -----------------------------
// AUDIT & ACTIVITY TRACKING
// -----------------------------
model ActivityLog {
  id        String  @id @default(cuid())
  userId    String
  action    String // e.g., "CREATE", "UPDATE", "DELETE"
  entity    String // e.g., "Product", "PurchaseOrder"
  entityId  String
  changes   Json? // Store before/after state; be careful with PII/size
  ipAddress String?

  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([entity, entityId])
  @@index([createdAt])
  @@map("activity_logs")
}

// -----------------------------
// SYSTEM CONFIGURATION
// -----------------------------
model SystemSetting {
  id          String  @id @default(cuid())
  key         String  @unique
  value       String
  description String?

  updatedAt DateTime @updatedAt

  @@map("system_settings")
}
